'''
Логика поиска повторов задной длины n была такая:
длина повторая - это окно поиска, поэтому в нем проводят поиск - сравнивают идущие друг за другом куски послетовательности длины n
При этом поиск с первого элемента участквами по n символов недостаточен - нужно проводить поиск свдигая начало на 1 символ до n-1
например в последовательности abcdefgdefgxyz ищем 4-символьный повтор, сравниваем по 4 символа начиная со следующих последовательностей:
i=0: abcd efgd efgx yz - нет повторов
i=1: bcde fgde fgxy z - нет повторов
i=2: cdef gdef gxyz - нет повторов
i=3: defg defg xyz - есть тандемный повтров
дальше сдвигать не имеет смылса - этот сдвиг уже проверялся

для этого используются ряд функций:
1. исходная последовательность разбивается на список из последовательностей длиной по n с учетом сдвига старта
и кажждый из этих сдвинутых списков сожержит список фрагментов последвоательности равной длине искомого повтора
2. передаем результа первой функции в фнукую коотрая ищет подходящей длины во вспех этих списках и возвращает в виде списка слвоарей
где слвоарь=повтор
3.соритровка спсика по индексу начала
4.оционально - удаленеи вложеных повторов


первая функция дробление списка исходя из длины повтора
функция разбивает последовательность на несколько со сдвигом первого элемента а 1 вправо,
при этом формирующиеся последовательности содержат в n_fold раз меньше элементов
'''
 
def fold (seq, n_fold): #n_fold - длина повтора	
    seq_new = list (seq) #последовательность переводится в список (зачем то)
	seq_new.remove("\n") #если остался знак переноса внутри или в конце (если вставлять ctrl-c - ctrl-v)
	seq_temporary = [] #список будет содержать n_fold-1 списков с фрагментами требуемого размера
	for j in range (0,n_fold): #этот цикл для разбивки с по раздным сдвигам
		seq_temporary_2 = [] #список для конкретного сдвига последовательности
		for i in range (j, len(seq_new),n_fold):# здесь происходит дробление последовательности (сейчас она лежитв в виде списка символов)
			if i+j <= len(seq_new):	#при таком условии длина последних элементов может быть меньше длины остальных, что оприори делает их не идентичными при последующем поиске
				#сначала я хотел, чтобы таких неполных элеметов вообще не было в результирующем списке (это съэкономит ресуры), но так и не смог придумать условие  чтобы реальзовать 
				#такой алгоритм
				new_item=""
				#теперь из символов-элемнов списка слепляются строки равне запрашиваемой длине n_fold
                # потмо они записываются с список для конктерного сдвига 
				new_item = new_item.join(seq_new [i:i+n_fold])
				seq_temporary_2.append(new_item)
		seq_temporary.append(seq_temporary_2) #запись в общий спсиок
	return seq_temporary # возвращает список, с элеметнами-списками новых последовательностей полученых фреймшифтом, 
#где элементы уже не один символ - а строка равная длине повтора

'''
вторая функция - собственно поиск повтров среди все возможных элементов
на вход - список со списками, длина звена повтора
'''

def poly_repeat(folded_seq, n_fold): #находит тип повтроа, начало и конец каждого повтроа
	frameshift = -1
	repeat_list =[] #сюда будут записываться все найденые повтроы (их чесато бывает несколько типов)
	for fr_list in folded_seq: #перебирем среди списков с разными сдвигами 
		frameshift +=1 #какой сдвиг сейчас проверяется
		letter = [] #записывается что какое звено повторяется
		first_index = [] #для каждого из наденых типов повтров записыапется какой по счету из сравниваемых фрагментов первое звено вповторе в свой список
		last_index = [] #для каждого из наденых типов повтров записыапется  какой по счету из сравниваемых фрагментов послежний для даноого типа повтора
		number_of_repeats = 0 #счетчик найдленых повторов
		if fr_list[0] == fr_list[1]:   #проверка начального элемента   (то есть првоерка граниных элементов)                         
				first_index.append(0) #если повторы начинаются  с него то начало повтороров - первое по счету звено
		for i in range(1, len(fr_list)-1): #сравниваем последовательно со второго о предпоследнего элемнта                   
			if fr_list[i]== fr_list [i+1] and fr_list [i] != fr_list [i-1]:
				first_index.append(i) #записываем первый найденый повтроры

			if fr_list [i] == fr_list [i-1] and fr_list [i]!=fr_list [i+1]:
				last_index.append(i) #записываем последненее найденое звено для каждого повтора
				letter.append(fr_list [i]) #записываем какой что за звено повтрояется (когда нашли окончание повтра)
				number_of_repeats+=1 #счетчик найденых повторов  во время последнего найденого
	

		if fr_list [-1] == fr_list [-2]:   #проверка конечного элемента
			letter.append(fr_list [-1])
			last_index.append (len(fr_list)-1)
			number_of_repeats += 1
			#все найденые повторы и их характеристики для провереного сдвига (frameshift)  
		a = [letter,first_index, last_index, number_of_repeats, frameshift, n_fold]
		dict_n = dict_poly_repeat (*a) #сквозые списки по одинпковым характеритсика списоки внутри списки переформатируются в словари под каждый повтор (зачем тут *???)
		repeat_list.extend(dict_n) #список сдловарей поаторов для текущегго сдвига добавляется в общий список 
	return repeat_list #формируем список, где для каждого сдвига считывания есть список с найдеными повторяющимимся элементами

''' 
вспомогательаня функция для формирвоания словаря для каждого повтора
на вход получает элемнеты описанне выше
'''


def dict_poly_repeat (letter, first_index, last_index, number_of_repeats, frameshift, n_fold):
        repeats = []
        for i in range (number_of_repeats):
		#словарь под конкретный повтор, в цикле идет запись характеристик для каждого повтора
                d = {"Type":None, "unit lengh":0,  "start index":0, "end index":0, "lengh total":0, "number of units in the tract":0, "frameshift": 0}
                d["Type"] = letter[i]
                d["unit lengh"] = n_fold
                start = (first_index[i]*n_fold)+frameshift	#пересчет индекса первого символа в этом тракте в первоначальной последовательности
                d["start index"] = start
                end = ((last_index[i]+1)*n_fold-1)+frameshift #пересчет индекса последнего символа в этом тракте в изначальной последовательности
                d["end index"] = end
                d["lengh total"] = (end - start)+1 #длина участка
                d["number of units in the tract"] = ((end - start)+1)//n_fold #количество звеньев во всем повторе
                d["frameshift"] = frameshift
                repeats.append(d)  #список с последовательным описанием каждого повтора в пределах одной рамки             
        return repeats

'''
далее список повтров нужно отсортировать - распиахл по трем функциям
в фнукцию sorting_3 передается спиоск найденых повтров после функции poly_repeat, внутри онап рименяет функции
sorting и sorting_2

наверно стоило использвоать сортировку по ключу
'''

#сортировка списка по начальному индексу повтора - по возвастанию
def sorting_3 (repeat_list):
	for begin in range (len(repeat_list)): #неудачно назавл begin для перебора повторов
		i = sorting(repeat_list,begin) #првоерка каждого элемента послдеовательно сти и поис минимального начальноги индекса
		sorting_2(repeat_list, begin, i) #перестановка текущего с минимальным на каждом шаге цикла
	return repeat_list

def sorting (repeat_list, begin): #проверяем явлесят ли элемент списка пвотров (каждый элемент -словарь)  с выбраным индексом минимальным
		min_index = begin
		current_min = repeat_list[begin]
		for i in range (begin, len(repeat_list)): #здесь цикл в цикле, похожечто сложность алгоритма увеличилась
			if repeat_list[i]["start index"] < current_min["start index"]: #проверяем всему последующему списку повторов
				min_index = i
				current_min = repeat_list[i]
		return min_index #имнимальный индекс на каждом шаге 

def sorting_2 (repeat_list,i,j): #принимает список повтров, индекс поктора и индекс минимального повтора
	t = repeat_list[i]
	repeat_list[i] = repeat_list [j]
	repeat_list[j] = t

'''
далее опицональная функция по игнорированию вложеных повтров
#Удаление "вложеных повторов"(что бы в abcabcabc не выводились bca и сab - там где начало уже внутри найденого повотора).
#как рекализовать это внутри других циклов я так и не придумал ранее

явно не учел если разница больше 1 но меньше длины повтора - надо доделать
'''

def sec_rep_del (repeat_list): 
	repeat_list.reverse() #зачем переворачивал отсортированый список, видимо для вычитания чтобы отрицательны хчисел избежать?
	for i in range (len(repeat_list)-1):
		if (repeat_list[i]["start index"] - repeat_list[i+1]["start index"]) == 1:
			repeat_list[i] = 0 #обращать в повторо если его начальный  индекс следует за предыдыщим повром на 1
	repeat_list.reverse()
	repeat_list_short = list(filter(lambda x: x != 0, repeat_list)) #удаляем все вложеные (вроде если 0, то можно any или every?? испольховать, юез лямбды)
	return repeat_list_short

	
